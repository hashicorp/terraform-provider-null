---

<!-- Please do not edit this file, it is generated. -->
# generated by https://github.com/hashicorp/terraform-plugin-docs
page_title: "null_resource Resource - terraform-provider-null"
subcategory: ""
description: |-
  The null_resource resource implements the standard resource lifecycle but takes no further action. On Terraform 1.4 and later, use the terraform_data resource type https://developer.hashicorp.com/terraform/language/resources/terraform-data instead.
  The triggers argument allows specifying an arbitrary set of values that, when changed, will cause the resource to be replaced.
---

# null_resource

The `nullResource` resource implements the standard resource lifecycle but takes no further action. On Terraform 1.4 and later, use the [terraform_data resource type](https://developer.hashicorp.com/terraform/language/resources/terraform-data) instead.

The `triggers` argument allows specifying an arbitrary set of values that, when changed, will cause the resource to be replaced.

## Example Usage

```typescript
import * as constructs from "constructs";
import * as cdktf from "cdktf";
/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
import * as aws from "./.gen/providers/aws";
import * as NullProvider from "./.gen/providers/null";
class MyConvertedCode extends cdktf.TerraformStack {
  constructor(scope: constructs.Construct, name: string) {
    super(scope, name);
    /*In most cases loops should be handled in the programming language context and 
    not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
    you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
    you need to keep this like it is.*/
    const awsInstanceClusterCount = cdktf.TerraformCount.of(
      cdktf.Token.asNumber("3")
    );
    const awsInstanceCluster = new aws.instance.Instance(this, "cluster", {
      ami: "ami-0dcc1e21636832c5d",
      instanceType: "m5.large",
      count: awsInstanceClusterCount,
    });
    const nullProviderResourceCluster = new NullProvider.resource.Resource(
      this,
      "cluster_1",
      {
        connection: {
          host: cdktf.Fn.element(
            cdktf.propertyAccess(awsInstanceCluster, ["*", "public_ip"]),
            0
          ),
        },
        triggers: [
          {
            cluster_instance_ids: cdktf.Fn.join(
              ",",
              cdktf.Token.asList(
                cdktf.propertyAccess(awsInstanceCluster, ["*", "id"])
              )
            ),
          },
        ],
        provisioners: [
          {
            type: "remote-exec",
            inline: [
              "bootstrap-cluster.sh " +
                cdktf.Token.asString(
                  cdktf.Fn.join(
                    " ",
                    cdktf.Token.asList(
                      cdktf.propertyAccess(awsInstanceCluster, [
                        "*",
                        "private_ip",
                      ])
                    )
                  )
                ),
            ],
          },
        ],
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    nullProviderResourceCluster.overrideLogicalId("cluster");
  }
}

```

<!-- schema generated by tfplugindocs -->

## Schema

### Optional

- `triggers` (Map of String) A map of arbitrary strings that, when changed, will force the null resource to be replaced, re-running any associated provisioners.

### Read-Only

- `id` (String) This is set to a random value at create time.

<!-- cache-key: cdktf-0.17.0-pre.15 input-64734d251545a8102312ebf4d3b3acb298b9d9b9070729db262d9ba29176dd3d -->